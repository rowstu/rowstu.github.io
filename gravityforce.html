<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gravity Force - Cargo Rescue</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0a0a12;
            --bg-medium: #12121f;
            --accent-cyan: #00f0ff;
            --accent-orange: #ff6b35;
            --accent-green: #39ff14;
            --accent-red: #ff1744;
            --accent-yellow: #ffd600;
            --text-dim: #4a5568;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-dark);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
            color: #fff;
        }

        .game-container {
            position: relative;
            background: linear-gradient(135deg, #0d0d1a 0%, #1a1a2e 50%, #0d0d1a 100%);
            border: 3px solid var(--accent-cyan);
            border-radius: 8px;
            box-shadow:
                0 0 20px rgba(0, 240, 255, 0.3),
                inset 0 0 60px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.15) 2px,
                rgba(0, 0, 0, 0.15) 4px
            );
            pointer-events: none;
            z-index: 10;
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            z-index: 5;
            pointer-events: none;
        }

        .hud-left, .hud-right {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 8px;
            text-shadow: 0 0 10px currentColor;
        }

        .hud-label {
            color: var(--text-dim);
        }

        .fuel-bar, .shield-bar {
            width: 100px;
            height: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid currentColor;
            border-radius: 2px;
            overflow: hidden;
        }

        .fuel-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-orange), var(--accent-yellow));
            transition: width 0.1s;
        }

        .shield-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-cyan), var(--accent-green));
            transition: width 0.1s;
        }

        .score { color: var(--accent-yellow); }
        .level { color: var(--accent-cyan); }
        .lives { color: var(--accent-red); }
        .cargo { color: var(--accent-green); }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 18, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            text-align: center;
            padding: 20px;
        }

        .overlay.hidden {
            display: none;
        }

        .title {
            font-family: 'Orbitron', monospace;
            font-size: 32px;
            font-weight: 900;
            background: linear-gradient(180deg, var(--accent-cyan) 0%, var(--accent-orange) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0, 240, 255, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .subtitle {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            color: var(--accent-orange);
            margin-bottom: 30px;
        }

        .instructions {
            font-family: 'Orbitron', monospace;
            font-size: 11px;
            color: #8892b0;
            line-height: 2;
            margin-bottom: 30px;
            max-width: 400px;
        }

        .instructions strong {
            color: var(--accent-cyan);
        }

        .btn {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            font-weight: 700;
            padding: 15px 40px;
            background: transparent;
            border: 2px solid var(--accent-cyan);
            color: var(--accent-cyan);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn:hover {
            background: var(--accent-cyan);
            color: var(--bg-dark);
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.5);
        }

        .mobile-controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            display: none;
            justify-content: space-between;
            z-index: 15;
            pointer-events: none;
        }

        .control-group {
            display: flex;
            gap: 5px;
            pointer-events: auto;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 240, 255, 0.15);
            border: 2px solid var(--accent-cyan);
            border-radius: 50%;
            color: var(--accent-cyan);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s;
        }

        .control-btn:active, .control-btn.active {
            background: rgba(0, 240, 255, 0.4);
            transform: scale(0.95);
        }

        .control-btn.thrust {
            width: 80px;
            height: 80px;
            border-color: var(--accent-orange);
            color: var(--accent-orange);
            background: rgba(255, 107, 53, 0.15);
        }

        .control-btn.thrust:active, .control-btn.thrust.active {
            background: rgba(255, 107, 53, 0.4);
        }

        .control-btn.fire {
            border-color: var(--accent-red);
            color: var(--accent-red);
            background: rgba(255, 23, 68, 0.15);
        }

        .control-btn.fire:active, .control-btn.fire.active {
            background: rgba(255, 23, 68, 0.4);
        }

        @media (max-width: 800px) {
            .mobile-controls {
                display: flex;
            }
            .title {
                font-size: 24px;
            }
            .instructions {
                font-size: 9px;
            }
        }

        .message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', monospace;
            font-size: 16px;
            color: var(--accent-green);
            text-shadow: 0 0 20px currentColor;
            z-index: 15;
            animation: fadeOut 2s forwards;
            pointer-events: none;
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            70% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -70%) scale(1.2); }
        }
    </style>
</head>
<body>
    <div class="game-container" id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="scanlines"></div>

        <div class="hud">
            <div class="hud-left">
                <div class="hud-item score">
                    <span class="hud-label">SCORE</span>
                    <span id="score">0</span>
                </div>
                <div class="hud-item level">
                    <span class="hud-label">LEVEL</span>
                    <span id="level">1</span>
                </div>
                <div class="hud-item lives">
                    <span class="hud-label">LIVES</span>
                    <span id="lives">♥♥♥</span>
                </div>
            </div>
            <div class="hud-right">
                <div class="hud-item" style="color: var(--accent-orange)">
                    <span class="hud-label">FUEL</span>
                    <div class="fuel-bar">
                        <div class="fuel-fill" id="fuelBar"></div>
                    </div>
                </div>
                <div class="hud-item" style="color: var(--accent-cyan)">
                    <span class="hud-label">SHIELD</span>
                    <div class="shield-bar">
                        <div class="shield-fill" id="shieldBar"></div>
                    </div>
                </div>
                <div class="hud-item cargo">
                    <span class="hud-label">CARGO</span>
                    <span id="cargo">0/3</span>
                </div>
            </div>
        </div>

        <div class="overlay" id="startOverlay">
            <div class="title">GRAVITY FORCE</div>
            <div class="subtitle">CARGO RESCUE</div>
            <div class="instructions">
                <strong>ARROW KEYS / WASD</strong> - Rotate & Thrust<br>
                <strong>SPACE / X</strong> - Fire Missiles<br>
                <strong>P</strong> - Pause<br><br>
                Collect cargo boxes and return them to your base.<br>
                Watch your fuel! Land on pads to refuel.<br>
                Destroy enemy tanks, ships, and missile bases.
            </div>
            <button class="btn" id="startBtn">START MISSION</button>
        </div>

        <div class="overlay hidden" id="pauseOverlay">
            <div class="title">PAUSED</div>
            <button class="btn" id="resumeBtn">RESUME</button>
        </div>

        <div class="overlay hidden" id="gameOverOverlay">
            <div class="title">MISSION FAILED</div>
            <div class="subtitle" id="finalScore">SCORE: 0</div>
            <button class="btn" id="retryBtn">RETRY</button>
        </div>

        <div class="overlay hidden" id="levelCompleteOverlay">
            <div class="title">LEVEL COMPLETE</div>
            <div class="subtitle" id="levelBonus">BONUS: 1000</div>
            <button class="btn" id="nextLevelBtn">NEXT LEVEL</button>
        </div>

        <div class="mobile-controls" id="mobileControls">
            <div class="control-group">
                <button class="control-btn" id="btnLeft">◀</button>
                <button class="control-btn" id="btnRight">▶</button>
            </div>
            <div class="control-group">
                <button class="control-btn fire" id="btnFire">●</button>
                <button class="control-btn thrust" id="btnThrust">▲</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Responsive canvas sizing
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 20, 900);
            const maxHeight = Math.min(window.innerHeight - 20, 600);
            const ratio = 900 / 600;

            if (maxWidth / maxHeight > ratio) {
                canvas.height = maxHeight;
                canvas.width = maxHeight * ratio;
            } else {
                canvas.width = maxWidth;
                canvas.height = maxWidth / ratio;
            }

            document.getElementById('gameContainer').style.width = canvas.width + 'px';
            document.getElementById('gameContainer').style.height = canvas.height + 'px';
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game constants
        const WORLD_WIDTH = 900;
        const WORLD_HEIGHT = 600;
        const GRAVITY = 0.08;
        const THRUST_POWER = 0.2;
        const ROTATION_SPEED = 0.08;
        const MAX_VELOCITY = 6;
        const FUEL_CONSUMPTION = 0.15;
        const MISSILE_SPEED = 8;
        const MISSILE_COOLDOWN = 250;

        // Game state
        let gameState = 'start';
        let score = 0;
        let level = 1;
        let lives = 3;
        let paused = false;

        // Player ship
        let ship = {
            x: 100,
            y: 100,
            vx: 0,
            vy: 0,
            angle: 0,
            fuel: 100,
            shield: 100,
            hasCargo: false,
            thrusting: false,
            lastMissile: 0
        };

        // Game objects
        let terrain = [];
        let cargos = [];
        let enemies = [];
        let missiles = [];
        let enemyMissiles = [];
        let particles = [];
        let base = null;
        let fuelPads = [];
        let cargoCollected = 0;
        let cargoRequired = 3;

        // Input state
        const keys = {
            left: false,
            right: false,
            up: false,
            fire: false
        };

        // Level definitions
        const levels = [
            // Level 1 - Simple introduction
            {
                gravity: 0.06,
                cargoCount: 2,
                enemies: { tanks: 1, ships: 0, bases: 0 },
                fuelPads: 2,
                terrain: 'simple'
            },
            // Level 2 - Add more cargo and a ship
            {
                gravity: 0.07,
                cargoCount: 3,
                enemies: { tanks: 2, ships: 1, bases: 0 },
                fuelPads: 2,
                terrain: 'caves'
            },
            // Level 3 - Introduce missile bases
            {
                gravity: 0.08,
                cargoCount: 3,
                enemies: { tanks: 2, ships: 1, bases: 1 },
                fuelPads: 2,
                terrain: 'complex'
            },
            // Level 4 - Narrow passages
            {
                gravity: 0.08,
                cargoCount: 4,
                enemies: { tanks: 3, ships: 2, bases: 1 },
                fuelPads: 3,
                terrain: 'narrow'
            },
            // Level 5 - Full challenge
            {
                gravity: 0.09,
                cargoCount: 5,
                enemies: { tanks: 4, ships: 2, bases: 2 },
                fuelPads: 2,
                terrain: 'fortress'
            }
        ];

        function getLevelConfig() {
            const idx = Math.min(level - 1, levels.length - 1);
            return levels[idx];
        }

        // Generate terrain based on level type
        function generateTerrain(type) {
            terrain = [];
            const groundY = WORLD_HEIGHT - 50;

            // Always add boundaries
            terrain.push({ x: 0, y: 0, w: WORLD_WIDTH, h: 20, type: 'ceiling' });
            terrain.push({ x: 0, y: 0, w: 20, h: WORLD_HEIGHT, type: 'wall' });
            terrain.push({ x: WORLD_WIDTH - 20, y: 0, w: 20, h: WORLD_HEIGHT, type: 'wall' });

            if (type === 'simple') {
                // Simple ground with small hills
                terrain.push({ x: 0, y: groundY, w: WORLD_WIDTH, h: 50, type: 'ground' });
                terrain.push({ x: 300, y: groundY - 40, w: 100, h: 40, type: 'hill' });
                terrain.push({ x: 600, y: groundY - 60, w: 80, h: 60, type: 'hill' });
            } else if (type === 'caves') {
                terrain.push({ x: 0, y: groundY, w: WORLD_WIDTH, h: 50, type: 'ground' });
                // Overhangs
                terrain.push({ x: 200, y: 100, w: 150, h: 30, type: 'overhang' });
                terrain.push({ x: 500, y: 150, w: 200, h: 25, type: 'overhang' });
                terrain.push({ x: 350, y: groundY - 80, w: 120, h: 80, type: 'hill' });
                terrain.push({ x: 650, y: groundY - 50, w: 100, h: 50, type: 'hill' });
            } else if (type === 'complex') {
                terrain.push({ x: 0, y: groundY, w: 300, h: 50, type: 'ground' });
                terrain.push({ x: 400, y: groundY, w: WORLD_WIDTH - 400, h: 50, type: 'ground' });
                // Platforms
                terrain.push({ x: 150, y: 200, w: 120, h: 20, type: 'platform' });
                terrain.push({ x: 400, y: 280, w: 150, h: 20, type: 'platform' });
                terrain.push({ x: 650, y: 180, w: 100, h: 20, type: 'platform' });
                // Pillars
                terrain.push({ x: 250, y: groundY - 150, w: 40, h: 150, type: 'pillar' });
                terrain.push({ x: 550, y: groundY - 120, w: 50, h: 120, type: 'pillar' });
            } else if (type === 'narrow') {
                terrain.push({ x: 0, y: groundY, w: WORLD_WIDTH, h: 50, type: 'ground' });
                // Create narrow passages
                terrain.push({ x: 200, y: 80, w: 30, h: 300, type: 'wall' });
                terrain.push({ x: 200, y: 450, w: 30, h: 100, type: 'wall' });
                terrain.push({ x: 450, y: 0, w: 30, h: 200, type: 'wall' });
                terrain.push({ x: 450, y: 280, w: 30, h: 270, type: 'wall' });
                terrain.push({ x: 700, y: 100, w: 30, h: 250, type: 'wall' });
                terrain.push({ x: 700, y: 420, w: 30, h: 130, type: 'wall' });
            } else if (type === 'fortress') {
                terrain.push({ x: 0, y: groundY, w: WORLD_WIDTH, h: 50, type: 'ground' });
                // Fortress walls
                terrain.push({ x: 350, y: groundY - 200, w: 200, h: 30, type: 'roof' });
                terrain.push({ x: 350, y: groundY - 200, w: 30, h: 200, type: 'wall' });
                terrain.push({ x: 520, y: groundY - 200, w: 30, h: 200, type: 'wall' });
                // Outer defenses
                terrain.push({ x: 150, y: groundY - 100, w: 80, h: 100, type: 'bunker' });
                terrain.push({ x: 670, y: groundY - 100, w: 80, h: 100, type: 'bunker' });
                // Overhead
                terrain.push({ x: 100, y: 120, w: 250, h: 25, type: 'overhang' });
                terrain.push({ x: 550, y: 120, w: 250, h: 25, type: 'overhang' });
            }
        }

        function initLevel() {
            const config = getLevelConfig();

            // Reset ship
            ship.x = 80;
            ship.y = 100;
            ship.vx = 0;
            ship.vy = 0;
            ship.angle = 0;
            ship.fuel = 100;
            ship.shield = 100;
            ship.hasCargo = false;
            ship.thrusting = false;

            // Generate terrain
            generateTerrain(config.terrain);

            // Place base (home)
            base = { x: 50, y: WORLD_HEIGHT - 70, w: 60, h: 20 };

            // Place fuel pads
            fuelPads = [];
            const padPositions = [
                { x: 400, y: WORLD_HEIGHT - 70 },
                { x: 700, y: WORLD_HEIGHT - 70 },
                { x: 250, y: 220 }
            ];
            for (let i = 0; i < config.fuelPads && i < padPositions.length; i++) {
                fuelPads.push({ x: padPositions[i].x, y: padPositions[i].y, w: 50, h: 15 });
            }

            // Place cargo
            cargos = [];
            cargoCollected = 0;
            cargoRequired = config.cargoCount;
            const cargoPositions = [
                { x: 200, y: WORLD_HEIGHT - 90 },
                { x: 500, y: WORLD_HEIGHT - 90 },
                { x: 750, y: WORLD_HEIGHT - 90 },
                { x: 350, y: 250 },
                { x: 600, y: 200 }
            ];
            for (let i = 0; i < config.cargoCount && i < cargoPositions.length; i++) {
                cargos.push({
                    x: cargoPositions[i].x,
                    y: cargoPositions[i].y,
                    w: 20,
                    h: 15,
                    collected: false
                });
            }

            // Place enemies
            enemies = [];
            missiles = [];
            enemyMissiles = [];
            particles = [];

            // Tanks
            const tankPositions = [
                { x: 300, y: WORLD_HEIGHT - 65 },
                { x: 550, y: WORLD_HEIGHT - 65 },
                { x: 800, y: WORLD_HEIGHT - 65 },
                { x: 180, y: WORLD_HEIGHT - 65 }
            ];
            for (let i = 0; i < config.enemies.tanks && i < tankPositions.length; i++) {
                enemies.push({
                    type: 'tank',
                    x: tankPositions[i].x,
                    y: tankPositions[i].y,
                    w: 30,
                    h: 15,
                    health: 2,
                    lastShot: 0,
                    fireRate: 2000
                });
            }

            // Enemy ships
            for (let i = 0; i < config.enemies.ships; i++) {
                enemies.push({
                    type: 'ship',
                    x: 400 + i * 200,
                    y: 150 + i * 50,
                    w: 25,
                    h: 20,
                    vx: 1 + Math.random(),
                    vy: 0.5,
                    health: 3,
                    lastShot: 0,
                    fireRate: 1500
                });
            }

            // Missile bases
            const basePositions = [
                { x: 450, y: WORLD_HEIGHT - 70 },
                { x: 650, y: WORLD_HEIGHT - 70 }
            ];
            for (let i = 0; i < config.enemies.bases && i < basePositions.length; i++) {
                enemies.push({
                    type: 'missileBase',
                    x: basePositions[i].x,
                    y: basePositions[i].y,
                    w: 40,
                    h: 25,
                    health: 4,
                    lastShot: 0,
                    fireRate: 3000
                });
            }

            updateHUD();
        }

        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lives').textContent = '♥'.repeat(lives);
            document.getElementById('fuelBar').style.width = ship.fuel + '%';
            document.getElementById('shieldBar').style.width = ship.shield + '%';
            document.getElementById('cargo').textContent = `${cargoCollected}/${cargoRequired}`;
        }

        function showMessage(text, color = '#39ff14') {
            const msg = document.createElement('div');
            msg.className = 'message';
            msg.textContent = text;
            msg.style.color = color;
            document.getElementById('gameContainer').appendChild(msg);
            setTimeout(() => msg.remove(), 2000);
        }

        // Physics and collision
        function rectCollision(a, b) {
            return a.x < b.x + b.w &&
                   a.x + (a.w || 20) > b.x &&
                   a.y < b.y + b.h &&
                   a.y + (a.h || 20) > b.y;
        }

        function pointInRect(px, py, rect) {
            return px >= rect.x && px <= rect.x + rect.w &&
                   py >= rect.y && py <= rect.y + rect.h;
        }

        function getShipBounds() {
            return { x: ship.x - 12, y: ship.y - 10, w: 24, h: 20 };
        }

        function checkTerrainCollision() {
            const bounds = getShipBounds();
            for (const t of terrain) {
                if (rectCollision(bounds, t)) {
                    return true;
                }
            }
            return false;
        }

        function checkLanding(pad) {
            const bounds = getShipBounds();
            // Check if ship is above pad and moving slowly
            const onPad = bounds.x + bounds.w > pad.x &&
                         bounds.x < pad.x + pad.w &&
                         bounds.y + bounds.h >= pad.y - 5 &&
                         bounds.y + bounds.h <= pad.y + 10;
            const slowEnough = Math.abs(ship.vx) < 1 && Math.abs(ship.vy) < 1.5 && ship.vy >= 0;
            const upright = Math.abs(ship.angle) < 0.4 || Math.abs(ship.angle - Math.PI * 2) < 0.4;
            return onPad && slowEnough && upright;
        }

        function createExplosion(x, y, count = 20, color = '#ff6b35') {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 30 + Math.random() * 30,
                    color,
                    size: 2 + Math.random() * 3
                });
            }
        }

        function createThrustParticle() {
            const angle = ship.angle + Math.PI + (Math.random() - 0.5) * 0.5;
            const speed = 2 + Math.random() * 2;
            particles.push({
                x: ship.x - Math.sin(ship.angle) * 12,
                y: ship.y + Math.cos(ship.angle) * 12,
                vx: Math.cos(angle) * speed + ship.vx * 0.3,
                vy: Math.sin(angle) * speed + ship.vy * 0.3,
                life: 15 + Math.random() * 10,
                color: Math.random() > 0.5 ? '#ff6b35' : '#ffd600',
                size: 2 + Math.random() * 2
            });
        }

        function fireMissile() {
            const now = Date.now();
            if (now - ship.lastMissile < MISSILE_COOLDOWN) return;

            ship.lastMissile = now;
            missiles.push({
                x: ship.x + Math.sin(ship.angle) * 15,
                y: ship.y - Math.cos(ship.angle) * 15,
                vx: Math.sin(ship.angle) * MISSILE_SPEED + ship.vx * 0.3,
                vy: -Math.cos(ship.angle) * MISSILE_SPEED + ship.vy * 0.3,
                life: 100
            });
        }

        function enemyFire(enemy) {
            const now = Date.now();
            if (now - enemy.lastShot < enemy.fireRate) return;

            enemy.lastShot = now;
            const dx = ship.x - enemy.x;
            const dy = ship.y - enemy.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist > 400) return; // Out of range

            const speed = enemy.type === 'missileBase' ? 4 : 3;
            enemyMissiles.push({
                x: enemy.x,
                y: enemy.y - 10,
                vx: (dx / dist) * speed,
                vy: (dy / dist) * speed,
                life: 150,
                type: enemy.type
            });
        }

        function damageShip(amount) {
            ship.shield -= amount;
            createExplosion(ship.x, ship.y, 10, '#00f0ff');

            if (ship.shield <= 0) {
                destroyShip();
            }
        }

        function destroyShip() {
            createExplosion(ship.x, ship.y, 40, '#ff1744');
            lives--;

            if (lives <= 0) {
                gameState = 'gameover';
                document.getElementById('finalScore').textContent = `SCORE: ${score}`;
                document.getElementById('gameOverOverlay').classList.remove('hidden');
            } else {
                // Respawn
                ship.x = 80;
                ship.y = 100;
                ship.vx = 0;
                ship.vy = 0;
                ship.angle = 0;
                ship.fuel = 100;
                ship.shield = 100;
                ship.hasCargo = false;
                showMessage('SHIP LOST', '#ff1744');
            }
            updateHUD();
        }

        function update() {
            if (gameState !== 'playing' || paused) return;

            const config = getLevelConfig();

            // Ship rotation
            if (keys.left) ship.angle -= ROTATION_SPEED;
            if (keys.right) ship.angle += ROTATION_SPEED;

            // Normalize angle
            while (ship.angle < 0) ship.angle += Math.PI * 2;
            while (ship.angle >= Math.PI * 2) ship.angle -= Math.PI * 2;

            // Thrust
            ship.thrusting = keys.up && ship.fuel > 0;
            if (ship.thrusting) {
                ship.vx += Math.sin(ship.angle) * THRUST_POWER;
                ship.vy -= Math.cos(ship.angle) * THRUST_POWER;
                ship.fuel -= FUEL_CONSUMPTION;
                if (ship.fuel < 0) ship.fuel = 0;

                if (Math.random() > 0.3) createThrustParticle();
            }

            // Gravity
            ship.vy += config.gravity;

            // Velocity limits
            const speed = Math.sqrt(ship.vx * ship.vx + ship.vy * ship.vy);
            if (speed > MAX_VELOCITY) {
                ship.vx = (ship.vx / speed) * MAX_VELOCITY;
                ship.vy = (ship.vy / speed) * MAX_VELOCITY;
            }

            // Move ship
            ship.x += ship.vx;
            ship.y += ship.vy;

            // Boundary checks
            if (ship.x < 30) { ship.x = 30; ship.vx = 0; }
            if (ship.x > WORLD_WIDTH - 30) { ship.x = WORLD_WIDTH - 30; ship.vx = 0; }
            if (ship.y < 30) { ship.y = 30; ship.vy = 0; }

            // Terrain collision
            if (checkTerrainCollision()) {
                if (Math.abs(ship.vx) > 2 || Math.abs(ship.vy) > 2) {
                    destroyShip();
                } else {
                    // Gentle bump
                    ship.vx *= -0.3;
                    ship.vy *= -0.3;
                    ship.x -= ship.vx * 2;
                    ship.y -= ship.vy * 2;
                }
            }

            // Check fuel pad landing
            for (const pad of fuelPads) {
                if (checkLanding(pad)) {
                    ship.vy = 0;
                    ship.y = pad.y - 10;
                    ship.fuel = Math.min(100, ship.fuel + 0.5);
                    ship.shield = Math.min(100, ship.shield + 0.2);
                }
            }

            // Check base landing
            if (checkLanding(base)) {
                ship.vy = 0;
                ship.y = base.y - 10;

                if (ship.hasCargo) {
                    ship.hasCargo = false;
                    cargoCollected++;
                    score += 500;
                    showMessage('CARGO DELIVERED! +500');

                    if (cargoCollected >= cargoRequired) {
                        // Level complete
                        const bonus = Math.floor(ship.fuel * 10 + ship.shield * 5);
                        score += bonus;
                        gameState = 'levelComplete';
                        document.getElementById('levelBonus').textContent = `BONUS: ${bonus}`;
                        document.getElementById('levelCompleteOverlay').classList.remove('hidden');
                    }
                }

                // Refuel at base
                ship.fuel = Math.min(100, ship.fuel + 0.3);
            }

            // Check cargo pickup
            if (!ship.hasCargo) {
                for (const cargo of cargos) {
                    if (!cargo.collected) {
                        const bounds = getShipBounds();
                        if (rectCollision(bounds, cargo)) {
                            cargo.collected = true;
                            ship.hasCargo = true;
                            score += 100;
                            showMessage('CARGO ACQUIRED! +100', '#00f0ff');
                        }
                    }
                }
            }

            // Fire missiles
            if (keys.fire) {
                fireMissile();
            }

            // Update player missiles
            for (let i = missiles.length - 1; i >= 0; i--) {
                const m = missiles[i];
                m.x += m.vx;
                m.y += m.vy;
                m.life--;

                // Check terrain collision
                let hit = false;
                for (const t of terrain) {
                    if (pointInRect(m.x, m.y, t)) {
                        hit = true;
                        createExplosion(m.x, m.y, 8, '#ffd600');
                        break;
                    }
                }

                // Check enemy collision
                if (!hit) {
                    for (const enemy of enemies) {
                        if (pointInRect(m.x, m.y, enemy)) {
                            hit = true;
                            enemy.health--;
                            createExplosion(m.x, m.y, 12, '#ff6b35');

                            if (enemy.health <= 0) {
                                const points = enemy.type === 'tank' ? 200 :
                                              enemy.type === 'ship' ? 300 : 400;
                                score += points;
                                showMessage(`${enemy.type.toUpperCase()} DESTROYED! +${points}`);
                                createExplosion(enemy.x, enemy.y, 30, '#ff1744');
                                enemies.splice(enemies.indexOf(enemy), 1);
                            }
                            break;
                        }
                    }
                }

                if (hit || m.life <= 0 || m.x < 0 || m.x > WORLD_WIDTH || m.y < 0 || m.y > WORLD_HEIGHT) {
                    missiles.splice(i, 1);
                }
            }

            // Update enemies
            for (const enemy of enemies) {
                if (enemy.type === 'ship') {
                    // Move enemy ship
                    enemy.x += enemy.vx;
                    enemy.y += enemy.vy;

                    // Bounce off walls
                    if (enemy.x < 50 || enemy.x > WORLD_WIDTH - 50) enemy.vx *= -1;
                    if (enemy.y < 80 || enemy.y > WORLD_HEIGHT - 150) enemy.vy *= -1;
                }

                // Fire at player
                const dx = ship.x - enemy.x;
                const dy = ship.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 350) {
                    enemyFire(enemy);
                }

                // Check collision with player
                const bounds = getShipBounds();
                if (rectCollision(bounds, enemy)) {
                    damageShip(30);
                    enemy.health--;
                    if (enemy.health <= 0) {
                        enemies.splice(enemies.indexOf(enemy), 1);
                    }
                }
            }

            // Update enemy missiles
            for (let i = enemyMissiles.length - 1; i >= 0; i--) {
                const m = enemyMissiles[i];
                m.x += m.vx;
                m.y += m.vy;
                m.life--;

                // Check player collision
                const bounds = getShipBounds();
                if (pointInRect(m.x, m.y, bounds)) {
                    damageShip(20);
                    enemyMissiles.splice(i, 1);
                    continue;
                }

                // Check terrain collision
                let hit = false;
                for (const t of terrain) {
                    if (pointInRect(m.x, m.y, t)) {
                        hit = true;
                        break;
                    }
                }

                if (hit || m.life <= 0 || m.x < 0 || m.x > WORLD_WIDTH || m.y < 0 || m.y > WORLD_HEIGHT) {
                    enemyMissiles.splice(i, 1);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.05; // Particle gravity
                p.life--;
                p.size *= 0.97;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            updateHUD();
        }

        function draw() {
            const scaleX = canvas.width / WORLD_WIDTH;
            const scaleY = canvas.height / WORLD_HEIGHT;

            ctx.save();
            ctx.scale(scaleX, scaleY);

            // Clear with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, WORLD_HEIGHT);
            gradient.addColorStop(0, '#0a0a15');
            gradient.addColorStop(0.5, '#0d1020');
            gradient.addColorStop(1, '#0a0a15');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

            // Draw stars
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 50; i++) {
                const x = (i * 137.5) % WORLD_WIDTH;
                const y = (i * 89.3) % WORLD_HEIGHT;
                const size = (i % 3) * 0.5 + 0.5;
                ctx.globalAlpha = 0.3 + (i % 5) * 0.1;
                ctx.fillRect(x, y, size, size);
            }
            ctx.globalAlpha = 1;

            // Only draw game elements if level is initialized
            if (!base) {
                ctx.restore();
                return;
            }

            // Draw terrain
            for (const t of terrain) {
                const terrainGrad = ctx.createLinearGradient(t.x, t.y, t.x, t.y + t.h);
                terrainGrad.addColorStop(0, '#3d4f5f');
                terrainGrad.addColorStop(1, '#1a252f');
                ctx.fillStyle = terrainGrad;
                ctx.fillRect(t.x, t.y, t.w, t.h);

                // Highlight
                ctx.strokeStyle = '#4a6070';
                ctx.lineWidth = 2;
                ctx.strokeRect(t.x, t.y, t.w, t.h);
            }

            // Draw base
            ctx.fillStyle = '#00f0ff';
            ctx.fillRect(base.x, base.y, base.w, base.h);
            ctx.fillStyle = '#00f0ff';
            ctx.globalAlpha = 0.3;
            ctx.fillRect(base.x - 5, base.y - 30, base.w + 10, 30);
            ctx.globalAlpha = 1;

            // Base label
            ctx.fillStyle = '#00f0ff';
            ctx.font = '10px Orbitron';
            ctx.textAlign = 'center';
            ctx.fillText('BASE', base.x + base.w/2, base.y - 5);

            // Draw fuel pads
            for (const pad of fuelPads) {
                ctx.fillStyle = '#ffd600';
                ctx.fillRect(pad.x, pad.y, pad.w, pad.h);
                ctx.fillStyle = '#ffd600';
                ctx.globalAlpha = 0.3;
                ctx.fillRect(pad.x - 3, pad.y - 20, pad.w + 6, 20);
                ctx.globalAlpha = 1;

                ctx.fillStyle = '#ffd600';
                ctx.font = '8px Orbitron';
                ctx.fillText('FUEL', pad.x + pad.w/2, pad.y - 5);
            }

            // Draw cargo
            for (const cargo of cargos) {
                if (!cargo.collected) {
                    ctx.fillStyle = '#39ff14';
                    ctx.fillRect(cargo.x, cargo.y, cargo.w, cargo.h);
                    ctx.strokeStyle = '#7fff00';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(cargo.x, cargo.y, cargo.w, cargo.h);

                    // Cargo glow
                    ctx.shadowColor = '#39ff14';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(cargo.x + 2, cargo.y + 2, cargo.w - 4, cargo.h - 4);
                    ctx.shadowBlur = 0;
                }
            }

            // Draw enemies
            for (const enemy of enemies) {
                if (enemy.type === 'tank') {
                    // Tank body
                    ctx.fillStyle = '#8b0000';
                    ctx.fillRect(enemy.x - 15, enemy.y - 8, 30, 16);
                    // Turret
                    ctx.fillStyle = '#a52a2a';
                    ctx.fillRect(enemy.x - 5, enemy.y - 12, 10, 8);
                    // Barrel
                    const angle = Math.atan2(ship.y - enemy.y, ship.x - enemy.x);
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y - 8);
                    ctx.rotate(angle - Math.PI/2);
                    ctx.fillStyle = '#cd5c5c';
                    ctx.fillRect(-2, -15, 4, 15);
                    ctx.restore();
                } else if (enemy.type === 'ship') {
                    // Enemy ship
                    ctx.save();
                    ctx.translate(enemy.x, enemy.y);
                    ctx.fillStyle = '#9400d3';
                    ctx.beginPath();
                    ctx.moveTo(0, -12);
                    ctx.lineTo(10, 10);
                    ctx.lineTo(-10, 10);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#da70d6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                } else if (enemy.type === 'missileBase') {
                    // Missile base
                    ctx.fillStyle = '#4a0080';
                    ctx.fillRect(enemy.x - 20, enemy.y - 10, 40, 20);
                    ctx.fillStyle = '#6a0dad';
                    ctx.beginPath();
                    ctx.moveTo(enemy.x - 15, enemy.y - 10);
                    ctx.lineTo(enemy.x, enemy.y - 25);
                    ctx.lineTo(enemy.x + 15, enemy.y - 10);
                    ctx.closePath();
                    ctx.fill();
                    // Radar dish
                    ctx.strokeStyle = '#9370db';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y - 20, 8, Math.PI, 0);
                    ctx.stroke();
                }
            }

            // Draw particles
            for (const p of particles) {
                ctx.globalAlpha = p.life / 60;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Draw missiles
            ctx.fillStyle = '#ffd600';
            for (const m of missiles) {
                ctx.beginPath();
                ctx.arc(m.x, m.y, 3, 0, Math.PI * 2);
                ctx.fill();

                // Trail
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(m.x, m.y);
                ctx.lineTo(m.x - m.vx * 2, m.y - m.vy * 2);
                ctx.stroke();
            }

            // Draw enemy missiles
            for (const m of enemyMissiles) {
                ctx.fillStyle = m.type === 'missileBase' ? '#ff00ff' : '#ff1744';
                ctx.beginPath();
                ctx.arc(m.x, m.y, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = m.type === 'missileBase' ? '#ff69b4' : '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(m.x, m.y);
                ctx.lineTo(m.x - m.vx * 3, m.y - m.vy * 3);
                ctx.stroke();
            }

            // Draw ship
            if (gameState === 'playing') {
                ctx.save();
                ctx.translate(ship.x, ship.y);
                ctx.rotate(ship.angle);

                // Ship body
                ctx.fillStyle = ship.hasCargo ? '#39ff14' : '#00f0ff';
                ctx.beginPath();
                ctx.moveTo(0, -15);
                ctx.lineTo(10, 12);
                ctx.lineTo(0, 8);
                ctx.lineTo(-10, 12);
                ctx.closePath();
                ctx.fill();

                // Ship outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Cockpit
                ctx.fillStyle = '#0a0a12';
                ctx.beginPath();
                ctx.arc(0, -2, 4, 0, Math.PI * 2);
                ctx.fill();

                // Thrust flame
                if (ship.thrusting) {
                    ctx.fillStyle = '#ff6b35';
                    ctx.beginPath();
                    ctx.moveTo(-5, 12);
                    ctx.lineTo(0, 12 + 10 + Math.random() * 8);
                    ctx.lineTo(5, 12);
                    ctx.closePath();
                    ctx.fill();

                    ctx.fillStyle = '#ffd600';
                    ctx.beginPath();
                    ctx.moveTo(-3, 12);
                    ctx.lineTo(0, 12 + 6 + Math.random() * 4);
                    ctx.lineTo(3, 12);
                    ctx.closePath();
                    ctx.fill();
                }

                // Cargo indicator
                if (ship.hasCargo) {
                    ctx.fillStyle = '#39ff14';
                    ctx.fillRect(-6, 5, 12, 6);
                }

                ctx.restore();

                // Low fuel warning
                if (ship.fuel < 20) {
                    ctx.fillStyle = `rgba(255, 107, 53, ${0.5 + Math.sin(Date.now() / 100) * 0.3})`;
                    ctx.font = 'bold 14px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText('LOW FUEL', WORLD_WIDTH / 2, 60);
                }

                // Shield warning
                if (ship.shield < 30) {
                    ctx.fillStyle = `rgba(255, 23, 68, ${0.5 + Math.sin(Date.now() / 100) * 0.3})`;
                    ctx.font = 'bold 14px Orbitron';
                    ctx.textAlign = 'center';
                    ctx.fillText('SHIELD CRITICAL', WORLD_WIDTH / 2, 80);
                }
            }

            ctx.restore();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = true;
            if (e.key === ' ' || e.key === 'x' || e.key === 'X') {
                keys.fire = true;
                e.preventDefault();
            }
            if (e.key === 'p' || e.key === 'P') {
                if (gameState === 'playing') {
                    paused = !paused;
                    document.getElementById('pauseOverlay').classList.toggle('hidden', !paused);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.up = false;
            if (e.key === ' ' || e.key === 'x' || e.key === 'X') keys.fire = false;
        });

        // Mobile controls
        function setupMobileControl(btnId, key) {
            const btn = document.getElementById(btnId);

            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                keys[key] = true;
                btn.classList.add('active');
            });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                keys[key] = false;
                btn.classList.remove('active');
            });

            btn.addEventListener('touchcancel', (e) => {
                keys[key] = false;
                btn.classList.remove('active');
            });
        }

        setupMobileControl('btnLeft', 'left');
        setupMobileControl('btnRight', 'right');
        setupMobileControl('btnThrust', 'up');
        setupMobileControl('btnFire', 'fire');

        // Button handlers
        document.getElementById('startBtn').addEventListener('click', () => {
            document.getElementById('startOverlay').classList.add('hidden');
            gameState = 'playing';
            level = 1;
            score = 0;
            lives = 3;
            initLevel();
        });

        document.getElementById('resumeBtn').addEventListener('click', () => {
            paused = false;
            document.getElementById('pauseOverlay').classList.add('hidden');
        });

        document.getElementById('retryBtn').addEventListener('click', () => {
            document.getElementById('gameOverOverlay').classList.add('hidden');
            gameState = 'playing';
            level = 1;
            score = 0;
            lives = 3;
            initLevel();
        });

        document.getElementById('nextLevelBtn').addEventListener('click', () => {
            document.getElementById('levelCompleteOverlay').classList.add('hidden');
            level++;
            gameState = 'playing';
            initLevel();
            showMessage(`LEVEL ${level}`, '#00f0ff');
        });

        // Start game loop
        gameLoop();
    </script>
</body>
</html>
